function [x,u,s,dv] = Constraints(Th,Nodes,Numb_Obst,Ad,Bd,xd_lb,xd_ub,vd_lb,vd_ub,ud_lb,ud_ub,spline_resolution)
    %% Develop the Nonlinear Constraints
    % Dermine the Lengths of the Input Matricies & Nodes
     A_len = size(Ad,2);
     B_len = size(Bd,2);
     Dims = A_len/2;

     % System States
     x_ic = sym('xic',[A_len 1],'real');                % Initial Condition Vector
     x = sym('x',[A_len Nodes],'real');                 % System State Matrix
     x_prev = sym('x_prev',[A_len Nodes],'real');       % Previous Optimization State Matrix
     u = sym('u',[B_len Nodes],'real');                 % Control Input Matrix  
     s = sym('s',[Numb_Obst Nodes], 'real');            % Slack Variable (Risk)

     % Obstacle States
     xo_ic = sym('xoic',[A_len Numb_Obst],'real');      % Initial Condition Vector   
     
     % Risk Constraint:
     m = sym('m', [spline_resolution 1], 'real');       % Slope of Spline
     b = sym('b', [spline_resolution 1], 'real');       % Intercept of Spline
     
     % Design Vector
     dv = [x(:); u(:); s(:)];                           % Design Vector has dt in it   
     
     %% Equality Constraint
     disp('Developing Equality Constraints...')
     % Impliment Dynamics x_dot = Ax + Bu
     dx = Ad*x + Bd*u;
     dt = Th/(Nodes-1);
     
     % Integration Method
     % Explicit Euler
     ceq_defect = x(:,2:end) - x(:,1:end-1) - dx(:,1:end-1)*dt;
     
     % Task Constraints - Initial and Final States, Obstacle Avoidance
     ceq_ic = x(:,1) - x_ic;
     
     % Combine the Equality Constraints
     ceq = [ceq_defect(:); ceq_ic(:)];

     % Seperate out the A and b
     Aeq = double(jacobian(ceq,dv));
     beq = -subs(ceq,dv,zeros(size(dv)));
     
     %% Inequality Constraints
     disp('Developing Inequality Constraints...')
     % Cartesian Bound equalities
     ciq_x_lb = -x(1:Dims,:) + xd_lb;
     ciq_x_ub = x(1:Dims,:) - xd_ub;

     % Velocity Bound equalities
     ciq_v_lb = -x(Dims+1:end,:) + vd_lb;
     ciq_v_ub = x(Dims+1:end,:) - vd_ub;
     
     % Force Bound equations
     ciq_u_lb = -u + ud_lb;
     ciq_u_ub = u - ud_ub;
     
     % Risk Slack: -Inf < s < 0
     ciq_slack = s;     
     
     % Linearized Avoidance Constraint: CHANGE
     [delta, ~, ~, ~] = RiskSourceFormulation(x_ic, x, x_prev, xo_ic, Th, Nodes);
     
     % Risk Function: -Inf < s < m * delta + b
     rfun = sym(zeros(spline_resolution, Nodes));
     for i = 1:spline_resolution
        rfun(i, :) = s - (m(i) * delta + b(i));
     end
     ciq_risk = rfun;
     
     % Combine the Inequality Constraints
     ciq = [ciq_x_lb(:); ciq_x_ub(:); ciq_v_lb(:); ciq_v_ub(:); ciq_u_lb(:); ciq_u_ub(:); ciq_slack(:); ciq_risk(:)];
     
     % Seperate out the A and b
     Aiq = jacobian(ciq, dv);
     biq = -subs(ciq, dv, zeros(size(dv)));     
    
     %% Create functions    
     disp('Generating Equality Constraint Function...')     
     matlabFunction(Aeq,beq,'File',[pwd '/Functions/AutoGenerated/EqualityConstraints'],'vars',{x_ic},'Outputs',{'Aeq','beq'}); 
     disp('Generating Inequality Constraint Function...') 
     matlabFunction(Aiq,biq,'File',[pwd '/Functions/AutoGenerated/InequalityConstraints'],'vars',{x_ic, x_prev, xo_ic, m, b},'Outputs',{'Aiq','biq'}); 
end


