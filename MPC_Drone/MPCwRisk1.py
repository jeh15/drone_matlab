#First test of implementing MPC avoidance algorithm on drone

import numpy as np

from pycrazyswarm import *
import uav_trajectory
import motioncapture
import time
import matplotlib.pyplot as plt
import csv
#Setting up MATLAB
import matlab.engine            #import the matlab engine
eng = matlab.engine.start_matlab()  
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk')
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk/Functions')
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk/Functions/AutoGenerated')
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk/Functions/Dynamics')
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk/Functions/Geometry')
eng.addpath('/home/david/crazyswarm/ros_ws/src/crazyswarm/scripts/MPCRisk/Functions/Optimization')


#Defining time variable for keeping track of dt
lastObjTime = time.time()
lastDroneTime = time.time()

#Initializing array of previous positions (used in velocity calculations)
lastObjPos = np.array([0,0,0])
lastDronePos = np.array([0,0,0])

#Initializing state vectors
droneState = matlab.double([0.0,0.0,0.0,0.0])    #Drone state    [x,y,dx,dy]
droneState = eng.transpose(droneState)
objState = matlab.double([0.0,0.0,0.0,0.0])      #Obstacle state [x,y,dx,dy]
objState = eng.transpose(objState)
desState = matlab.double([0.0,0.0,0.0,0.0])      #Desired state  [x,y,dx,dy]
desState = eng.transpose(desState)

#Velocity array used for filtering object velocity
prevObjVel = np.zeros([5,3])

#Parameters to manipulate
sampleTime = 0.05  #amount of trajectory to be executed (in sec)
viconRate = 300 #Vicon sample rate

rate = 100.0    #rate of trajectory execution
Z = 0.4         #Z altitude
offset=np.array([0, 0, Z])


#Data Logging Setup
flightData = np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],dtype=float)
trajData = []
timeIter = 0
runNum = 0

#Function to write a new line of data to log file
def writeCSV(data,filename):
    with open (filename,'a',newline='') as outfile:
        writer = csv.writer(outfile)
        writer.writerow(data)

def saveFlightData(runNum,tc,droneState3D,objState3D,realTime):
    flightData[0] = runNum
    flightData[1] = tc
    flightData[2:8] = droneState3D
    flightData[8:14] = objState3D
    flightData[14] = realTime
    writeCSV(flightData,'flightLog.csv')


#Gets 3D state of object as numpy array
def getState3D(lastPos,pos,dTime):
    dPos = pos-lastPos
    vel = dPos.copy()/dTime
    state3D = np.array([pos[0],pos[1],pos[2],vel[0],vel[1],vel[2]])
    return state3D

#Gets 2D state of object as matlab double array
def getState(lastPos,pos,dTime):
    dPos = pos-lastPos
    vel = dPos.copy()/dTime
    state = matlab.double([pos[0].copy(),pos[1].copy(),vel[0].copy(),vel[1].copy()])
    state = eng.transpose(state)
    return state

#Function specifically used for object state that filters velocity
def getObjState(lastPos,pos,dTime,prevVels):
    dPos = pos-lastPos
    vel = dPos.copy()/dTime
    filtVel = velFilter(prevVels,vel)
    state = matlab.double([pos[0].copy(),pos[1].copy(),filtVel[0].copy(),filtVel[1].copy()])
    state = eng.transpose(state)
    return state

#Function to save trajectory data to a CSV file
def saveTrajData(currTrajFile,trajDataFile,runNum):
    with open(currTrajFile,newline='') as csvfile:
        currTraj = csv.reader(csvfile)
        for row in currTraj:
            row = [runNum] + row
            with open (trajDataFile,'a',newline='') as outfile:
                writer = csv.writer(outfile)
                writer.writerow(row)

#Function to filter velocity (simple moving average)
def velFilter(prevVels,vel):
    prevVels[4] = prevVels[3]
    prevVels[3] = prevVels[2]
    prevVels[2] = prevVels[1]
    prevVels[1] = prevVels[0]
    prevVels[0] = vel
    avgVel = sum(prevVels)/5
    return avgVel

#Variables and Function to control adversary drone
kp = [7, 9, 12]
kd = [3, 4, 3]
followOffset = np.array([0.0,0.0,0.0])

def followObj(droneState3D,objState3D):
    facc = kp*((followOffset + droneState3D[0:3])-objState3D[0:3]) + kd*(droneState3D[3:6]-objState3D[3:6])
    facc[2] = 0.0
    fvel = objState3D[3:6] + facc*dT
    fvel[2] = 0
    fpos = objState3D[0:3] + fvel*dT
    fpos[2] = Z
    fpos = fpos.astype('float')
    fvel = fvel.astype('float')
    facc = facc.astype('float')
    fyaw = 0.0
    fomega = [0.0,0.0,0.0]
    return [fpos,fvel,facc,fyaw,fomega]
    

#Main control script
if __name__ == "__main__":

#SETUP (Runs once)#
    
    #Initialize drone
    swarm = Crazyswarm()
    timeHelper = swarm.timeHelper
    cf1 = swarm.allcfs.crazyflies[0]
    cf2 = swarm.allcfs.crazyflies[1]
    
    

    #Call function to develop parameters for MPC
    [Th,Nodes,xd_lb,xd_ub,Numb_Obst,dims_x,Ad,Bd,spline_resolution] = eng.DevMPCRisk(nargout = 7)

    #Connect to mocap system
    mc = motioncapture.connect("vicon","192.168.1.119")

    #GET OBJECT AND DRONE STATE
    #Get one frame of data
    lt = time.time()
    lastObjPos = cf2.position()
    lastDronePos = cf1.position()
    dT = lt-time.time()
    while dT < 0.007:
        dT = time.time()-lt
        print(dT)

    #Get next frame of data
    mc.waitForNextFrame()  
    objPos = cf2.position()
    dronePos = cf1.position()
    dT = time.time()-lt

    #Get object state vector
    objState = getState(lastObjPos,objPos,dT)

    #Get drone state vector
    droneState = getState(lastDronePos,dronePos,dT)

    #Takeoff and wait for a second
    cf1.takeoff(targetHeight=Z, duration=Z+1.0)
    cf2.takeoff(targetHeight=Z, duration=Z+1.0)
    timeHelper.sleep(Z+2.0)

    #Start time
    lt = time.time()
    ti = time.time()

    #Clear previous data log file
    f1 = open("flightLog.csv","w")
    f1.truncate()
    f1.close()
    f2 = open("trajLog.csv","w")
    f2.truncate()
    f1.close()
    skipTime = 0.17
    
    print("Avoidance System Active")
    qd = eng.ones(int(Nodes),4)
    qd = eng.times(eng.transpose(droneState[:]), qd)

    eng.workspace['m'] = eng.zeros(spline_resolution, 1)
    eng.workspace['b'] = eng.zeros(spline_resolution, 1)

    #### Main avoidance loop ####
    try:
        while True:

            #Call RunMPC function to analyze state and generate new trajectory
            [qd,ud] = eng.RunMPCRisk(Th,Nodes,droneState,objState,desState,qd,xd_lb,xd_ub,m,b,nargout=2)
            
            traj = uav_trajectory.Trajectory()
            traj.loadcsv("TEST.csv")
            
            #Save trajectory data
            saveTrajData('TEST.csv','trajLog.csv',runNum)

            startTime = time.time()
            tc = 0
            while tc <= sampleTime:
                #Make sure dT is big enough to get good velocity measurements
                dT = time.time()-lt
                while dT <= 0.007:
                    dT = time.time()-lt
                #Get next frame of position data
                dronePos = cf1.position()
                objPos = cf2.position()
                #Calculate elapsed time since last position frame
                dT = time.time()-lt

                #Get object state vector
                objState = getObjState(lastObjPos,objPos,dT,prevObjVel)
                
                #Get drone state vector
                droneState = getState(lastDronePos,dronePos,dT)
                
                #Save data for logging
                droneState3D = getState3D(lastDronePos,dronePos,dT)
                objState3D = getState3D(lastObjPos,objPos,dT)

    
                #Save previous position data for next iteration
                lt = time.time()
                lastDronePos = dronePos.copy()
                lastObjPos = objPos.copy()

                #Calculate current time 
                tc = (time.time()-startTime)

                #Interpolate and execute trajectory 
                e = traj.eval(tc+skipTime)    
                cf1.cmdFullState(
                    e.pos + np.array(cf1.initialPosition) + offset,
                    e.vel,
                    e.acc,
                    e.yaw,
                    e.omega)    
                #Reuse last commanded velocity
                droneState = matlab.double([dronePos[0].copy(),dronePos[1].copy(),e.vel[0].copy(),e.vel[1].copy()])
                droneState = eng.transpose(droneState)
                
                #Call function to control follower drone (obj)
                [fpos,fvel,facc,fyaw,fomega] = followObj(droneState3D,objState3D)
                cf2.cmdFullState(fpos,fvel,facc,fyaw,fomega)
                timeHelper.sleepForRate(rate)

                #LOG FLIGHT DATA
                realTime = time.time()-ti
                saveFlightData(runNum,tc,droneState3D,objState3D,realTime)
            runNum += 1
                
            

            #### END main avoidance loop ####
    except KeyboardInterrupt:
        print("E-Stop")
    finally:
        print("EmergencyStop Activated")
        cf1.notifySetpointsStop()
        cf1.land(targetHeight=0.03, duration=Z+1.0)
        timeHelper.sleep(Z+2.0)
